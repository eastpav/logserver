/*
 * We want a reentrant scanner.
 */
%option reentrant

/*
 * We don't use input, so don't generate code for it.
 */
%option noinput

/*
 * We don't use unput, so don't generate code for it.
 */
%option nounput

/*
 * We don't read interactively from the terminal.
 */
%option never-interactive

/*
 * Prefix scanner routines with "df_" rather than "yy", so this scanner
 * can coexist with other scanners.
 */
%option prefix="tf_"

/*
 * We're reading from a string, so we don't need yywrap.
 */
%option noyywrap

/*
 * The type for the state we keep for a scanner.
 */
%option extra-type="tfScannerState_t *"

/*
 * We have to override the memory allocators so that we don't get
 * "unused argument" warnings from the yyscanner argument (which
 * we don't use, as we have a global memory allocator).
 *
 * We provide, as macros, our own versions of the routines generated by Flex,
 * which just call malloc()/realloc()/free() (as the Flex versions do),
 * discarding the extra argument.
 */
%option noyyalloc
%option noyyrealloc
%option noyyfree

%{
/*
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 2001 Gerald Combs
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <stdlib.h>
#include <errno.h>
#include <glib.h>

#include "filter.h"
#include "syntax-tree.h"
#include "grammar.h"
#include "proto.h"

#ifdef _WIN32
/* disable Windows VC compiler warning "signed/unsigned mismatch" associated  */
/* with YY_INPUT code generated by flex versions such as 2.5.35.              */
#pragma warning (disable:4018)
#endif

#define LVAL		tf_lval
#define LVAL_TYPE	stnode_t*
#define LVAL_INIT_VAL	NULL
#define MODNAME		tf
#define FLEX_YY_PREFIX	tf_

//#include <lemonflex-head.inc>

/*#undef YY_NO_UNPUT*/


static int simple(int token);


/*
 * Sleazy hack to suppress compiler warnings in yy_fatal_error().
 */
#define YY_EXIT_FAILURE ((void)yyscanner, 2)

/*
 * Macros for the allocators, to discard the extra argument.
 */
#define tf_alloc(size, yyscanner)		(void *)malloc(size)
#define tf_realloc(ptr, size, yyscanner)	(void *)realloc((char *)(ptr), (size))
#define tf_free(ptr, yyscanner)			free((char *)ptr)

%}

%x RANGE_INT
%x RANGE_PUNCT
%x DQUOTE

%%

[[:blank:]\n]+	/* ignore whitespace */



"("				return simple(TOKEN_LPAREN);
")"				return simple(TOKEN_RPAREN);

"=="			return simple(TOKEN_TEST_EQ);
"!="			return simple(TOKEN_TEST_NE);
">"				return simple(TOKEN_TEST_GT);
">="			return simple(TOKEN_TEST_GE);
"<"				return simple(TOKEN_TEST_LT);
"<="			return simple(TOKEN_TEST_LE);
"&&"			return simple(TOKEN_TEST_AND);
"||"			return simple(TOKEN_TEST_OR);


\042				{
	/* start quote */
	/* The example of how to scan for strings was taken from
	the flex 2.5.4 manual, from the section "Start Conditions".
	See:
	http://www.gnu.org/software/flex/manual/html_node/flex_11.html */

	BEGIN(DQUOTE);
	/* A previous filter that failed to compile due to
	a missing end quote will have left quotedString set
	to something. Clear it now that we are starting
	a new quoted string. */
	if (yyextra->quotedString) {
		//g_string_free(yyextra->quotedString, TRUE);
        //yyextra->quotedString->str[0] = 0;
        memset(yyextra->quotedString->str, 0, yyextra->quotedString->allocated_len);
        yyextra->quotedString->len = 0;
		/* Don't set quotedString to NULL, as we
		do in other quotedString-cleanup code, as we're
		about to set it in the next line. */
	}
	//yyextra->quotedString = g_string_new("");
}

<DQUOTE><<EOF>>				{
	/* unterminated string */
	/* The example of how to handle unclosed strings was taken from
	the flex 2.5.4 manual, from the section "End-of-file rules".
	See:
	http://www.gnu.org/software/flex/manual/html_node/flex_13.html */

	tfilter_fail(yyextra->ptf, "The final quote was missing from a quoted string.");
	return SCAN_FAILED;
}

<DQUOTE>\042			{
	/* end quote */
	//int token;
	BEGIN(INITIAL);
	//token = set_lval(TOKEN_STRING, yyextra->quotedString->str);
	//g_string_free(yyextra->quotedString, TRUE);
	//yyextra->quotedString = NULL;
	//return token;
    return TOKEN_STRING;
}

<DQUOTE>\\[0-7]{1,3} {
	/* octal sequence */
	unsigned long result;
	result = strtoul(yytext + 1, NULL, 8);
	if (result > 0xff) {
		//g_string_free(yyextra->quotedString, TRUE);
		//yyextra->quotedString = NULL;
		tfilter_fail(yyextra->ptf, "%s is larger than 255.", yytext);
		return SCAN_FAILED;
	}
	g_string_append_c(yyextra->quotedString, (gchar) result);
}

<DQUOTE>\\x[[:xdigit:]]{1,2} {
	/* hex sequence */
	unsigned long result;
	result = strtoul(yytext + 2, NULL, 16);
	g_string_append_c(yyextra->quotedString, (gchar) result);
}


<DQUOTE>\\.				{
	/* escaped character */
	g_string_append_c(yyextra->quotedString, yytext[1]);
}

<DQUOTE>[^\\\042]+			{
	/* non-escaped string */
	g_string_append(yyextra->quotedString, yytext);
}

0[xX][0-9a-fA-F]+            {
    //g_string_overwrite(yyextra->quotedString, 0, yytext);
    sprintf(yyextra->quotedString->str, "%s", yytext); 
    //return set_lval_int(yyextra->ptf, TOKEN_INTEGER, yytext);
    return TOKEN_INTEGER;
}

[0-9]+                           {
    //g_string_overwrite(yyextra->quotedString, 0, yytext);
    sprintf(yyextra->quotedString->str, "%s", yytext);
    //return set_lval_int(yyextra->ptf, TOKEN_INTEGER, yytext);
    return TOKEN_INTEGER;
}

[-[:alnum:]_\.:]*\/[[:digit:]]+  {
        /* CIDR */
        //g_string_overwrite(yyextra->quotedString, 0, yytext); 
        sprintf(yyextra->quotedString->str, "%s", yytext);
        //return set_lval(TOKEN_UNPARSED, yytext);
        return TOKEN_UNPARSED;
}

[-\+[:alnum:]_.:]+	{
    //g_string_overwrite(yyextra->quotedString, 0, yytext);
    sprintf(yyextra->quotedString->str, "%s", yytext);
    /* 
    gboolean exist = FALSE;
    exist = protoExist(yytext);
    if(exist)
    {
        return set_lval(TOKEN_FIELD, yytext);
    }
    else
    {
        return set_lval(TOKEN_STRING, yytext);
    }
    */
    return TOKEN_UNPARSED;
}

. {
	/* Default */
    //g_string_overwrite(yyextra->quotedString, 0, yytext);
    sprintf(yyextra->quotedString->str, "%s", yytext);
	//return set_lval(TOKEN_UNPARSED, yytext);
    return TOKEN_UNPARSED;
}


%%

static int
simple(int token)
{
	switch (token) {
		case TOKEN_LPAREN:
		case TOKEN_RPAREN:
		case TOKEN_TEST_EQ:
		case TOKEN_TEST_NE:
		case TOKEN_TEST_GT:
		case TOKEN_TEST_GE:
		case TOKEN_TEST_LT:
		case TOKEN_TEST_LE:
		case TOKEN_TEST_AND:
		case TOKEN_TEST_OR:
			break;
		default:
			g_assert_not_reached();
	}
	return token;
}


